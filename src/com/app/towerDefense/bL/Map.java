package com.app.towerDefense.bL;

import java.awt.Point;

import com.app.towerDefense.models.MapModel;
import com.app.towerDefense.staticContent.AppilicationEnums.*;

/**
 * This class validates map features(Entry,Exit,Scenery) and map path from the
 * root
 * 
 * @author Sajjad Ashraf
 *
 */
public class Map {

	/**
	 * This method validates the map
	 * 
	 * @param new_mapModel
	 *            as a map
	 * @return the routeStatus
	 */
	public String mapValidations(MapModel new_mapModel) {
		String routeStatus = null;
		if (!new_mapModel.isEntryDone || new_mapModel.getEntryPoint() == null) {
			routeStatus = "Please First Select an Entry Point.";
			new_mapModel.setMapAutoGeneratedDescription(routeStatus);
		}

		else if (!new_mapModel.isExitDone || new_mapModel.getExitPoint() == null) {
			routeStatus = "Please First Select an Exit Point.";
			new_mapModel.setMapAutoGeneratedDescription(routeStatus);
		}

		else {
			routeStatus = mapPathValidation(new_mapModel);
			if (routeStatus.contains("Success")) {
				new_mapModel.setMapAutoGeneratedDescription(routeStatus);
				routeStatus = null;
			} else {
				new_mapModel.setMapAutoGeneratedDescription(routeStatus);
			}
		}

		return routeStatus;

	}

	/**
	 * This method validates the map path
	 * 
	 * @param new_map the map
	 *            
	 * @return the status of the map verified or not-verified
	 */
	public String mapPathValidation(MapModel new_map) {
		int mapWidth = new_map.getMapWidth();
		int mapHeight = new_map.getMapHeight();
		Point entryPoint = new_map.getEntryPoint();
		Point exitPoint = new_map.getExitPoint();
		int mapPathCellCount = 1;// for Entry Point
		int mapRoutCount = 0;// map rout count
		String status = "";
		int i = entryPoint.x;
		int j = entryPoint.y;
		E_MapValidationDirecton dirUpDown = E_MapValidationDirecton.Initial;
		E_MapValidationDirecton dirLeftRight = E_MapValidationDirecton.Initial;
		while ((i >= 0 && i < mapHeight) || (j >= 0 && j < mapWidth)) {

			int cellValue = 0;
			int connectedCellFound = 0;

			// Checking for Down cell
			if (i < mapHeight
					&& (dirUpDown == E_MapValidationDirecton.Initial || dirUpDown == E_MapValidationDirecton.Down)) {
				if (i == mapHeight - 1) {
					dirUpDown = E_MapValidationDirecton.Up;
				} else {
					cellValue = new_map.getMapGridSelection()[i + 1][j];
					if (cellValue == 1) {
						i++;
						mapPathCellCount++;
						connectedCellFound++;
						dirUpDown = E_MapValidationDirecton.Down;
					} else if (cellValue == 3) // Check if it is Exit point
					{
						dirUpDown = E_MapValidationDirecton.Down;
						if (mapPathCellCount <= 2) {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Error:Cells:" + mapPathCellCount
									+ ":Map is not correct has only Entry and Exit points.";
							break;
						} else {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Success:Cells:" + mapPathCellCount + "";
							break;
						}
					}
				}

			}

			// Checking For Up Cell
			if (i >= 0 && (dirUpDown == E_MapValidationDirecton.Initial || dirUpDown == E_MapValidationDirecton.Up)) {
				if (i == 0) {
					dirUpDown = E_MapValidationDirecton.Down;
				} else {
					cellValue = new_map.getMapGridSelection()[i - 1][j];
					if (cellValue == 1) {
						i--;
						mapPathCellCount++;
						connectedCellFound++;
						dirUpDown = E_MapValidationDirecton.Up;
					} else if (cellValue == 3) {
						dirUpDown = E_MapValidationDirecton.Up;
						if (mapPathCellCount <= 2) {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Error:Cells:" + mapPathCellCount
									+ ":Map is not correct has only Entry and Exit points.";
							break;
						} else {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Success:Cells:" + mapPathCellCount + "";
							break;
						}
					}
				}

			}

			// Checking for Left cell
			if (j < mapWidth && (dirLeftRight == E_MapValidationDirecton.Initial
					|| dirLeftRight == E_MapValidationDirecton.Left)) {
				if (j == mapWidth - 1) {
					dirLeftRight = E_MapValidationDirecton.Right;
				} else {
					cellValue = new_map.getMapGridSelection()[i][j + 1];
					if (cellValue == 1) {
						j++;
						mapPathCellCount++;
						connectedCellFound++;
						dirLeftRight = E_MapValidationDirecton.Left;
					} else if (cellValue == 3) // Check if it is Exit point
					{
						dirLeftRight = E_MapValidationDirecton.Left;
						if (mapPathCellCount <= 2) {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Error:Cells:" + mapPathCellCount
									+ ":Map is not correct has only Entry and Exit points.";
							break;
						} else {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Success:Cells:" + mapPathCellCount + "";
							break;
						}
					}
				}

			}

			// Checking For Right Cell
			if (j >= 0 && (dirLeftRight == E_MapValidationDirecton.Initial
					|| dirLeftRight == E_MapValidationDirecton.Right)) {
				if (j == 0) {
					dirLeftRight = E_MapValidationDirecton.Left;
				} else {
					cellValue = new_map.getMapGridSelection()[i][j - 1];
					if (cellValue == 1) {
						j--;
						mapPathCellCount++;
						connectedCellFound++;
						dirLeftRight = E_MapValidationDirecton.Right;
					} else if (cellValue == 3) {
						dirLeftRight = E_MapValidationDirecton.Right;
						if (mapPathCellCount <= 2) {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Error:Cells:" + mapPathCellCount
									+ ":Map is not correct has only Entry and Exit points.";
							break;
						} else {
							mapPathCellCount++;
							connectedCellFound++;
							status = "Success:Cells:" + mapPathCellCount + "";
							break;
						}
					}
				}
			}
			if (connectedCellFound == 0) {
				status = "Error:Cells" + mapPathCellCount + ":Map is not Connected";
				break;
			}

		}

		return status;
	}
}
